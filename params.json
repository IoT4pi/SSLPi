{"name":"SSLPi","tagline":"secure communication for the raspberry pi and several type of clients","body":"![IoT4pi](https://github.com/IoT4pi/SSLPi/blob/master/images/IoT4Pi_Logo.png)\r\n#SSLPi\r\nsecure communication for the raspberry pi and several type of clients.\r\nThe main focus is on easy installation and no need for any cloud service.\r\nA direct communication between a raspberry pi an clients with the use of OpenSSL.\r\nWith the help of a configuration file you are able to implement your own applications onto the raspberry pi.\r\n\r\n##You'll find a German translated Version of the ReadMe at www.iot4pi.com .\r\n\r\n###So let's get started with the installation: \r\nAfter downloading the IoT4pi-SSLPi-XXXX.tar.gz to your System (Raspberry pi) to any given directory \r\nand extract it with the command\r\n\r\n    `$ tar -zxvf IoT4pi-SSLPi-XXXX.tar.gz`\r\n\r\n\r\nthis generate a directory IoT4pi-SSLPi-XXXX.\r\n(The X will vary depending on the version you have downloaded)\r\n\r\nChange into the directory with\r\n\r\n    `$ cd IoT4pi-SSLPi-XXXX`\r\n\r\nThere you will see with \"ls -l\"\r\n\r\n    pi@Mypi ~/SSLPi_VersX $ ls -l\r\n    drwxr-xr-x 2 pi pi  4096 Jan 27 13:12 app\r\n    drwxr-xr-x 2 pi pi  4096 Jan 27 13:12 Test\r\n    -rwxr-xr-x 1 pi pi  6656 Jan 27 14:23 Install.sh\r\n    -rw-r--r-- 1 pi pi  4923 Jan 27 15:30 ReadMe_Install\r\n    -rw-r--r-- 1 pi pi  4923 Jan 27 15:30 ReadMe_Config\r\n    -rw-r--r-- 1 pi pi  4923 Jan 27 15:30 SSLPi.cfg\r\n    -rw-r--r-- 1 pi pi 21557 Jan 27 15:24 SSLserverPi_VX.py\r\n    -rwxr-xr-x 1 pi pi   550 Jan 27 15:30 startSSLPi.sh\r\n\r\nIn the app directory are sample application, to show you how to configure \r\nthe SSLPi to your own demands. \r\n\r\nIn the TestClient directory is a sample Python SSL Client \r\nYou can use it and modify it to your own needs. \r\nIt is tested to work together with SSLPi Server.\r\n\r\nTo start the installation type \r\n\r\n`\t $ sudo ./Install.sh`\r\n\r\nThe script is going to proof if the prerequisite software is on your system.\r\nIt actually checks if the Python2.7 and OpenSSL is installed. \r\nIf not, it will exit the install script and you have to install the missing software. \r\n\r\nAs an information: \r\nyou can install OpenSSL with\r\n     `$ sudo apt-get install openssl`\r\n\r\nyou can install python with\r\n    `$ sudo apt-get install python2.7`\r\nBut I do not think this will happen very often,because the Raspberry (& Raspian) runs Python 2.7 out of the box\r\n\r\nNext you will be asked for directory, where the SSLPi Server has to be installed. If you do not specify a \r\ndirectory, the default directory will be created. the default directory is \r\n`     /home/pi/SSLPi/`\r\n\r\nNext type in where to install the certificates. The default directory is \r\n`    /home/pi/SSLPi/Cert/`\r\n\r\nAs a next step the script is creating the certificates. \r\nYou have to type in a password three times. It has to be the same password, all the time. \r\n\r\nAfterwards you are asked for several pieces of information.\r\n**One of the prompts will be for \"Common Name (e.g., YOUR name)\". It is important **\r\nthat this field be filled in with the fully qualified domain name of the server to be protected by SSL.\r\n\r\n    `Country Name (2 letter code) [GB]:DE`\r\n    `State or Province Name (full name) [Berkshire]:Bavaria`\r\n    `Locality Name (eg, city) [Newbury]:Munich`\r\n    `Organization Name (eg, company) [My Company Ltd]:IoT4pi`\r\n    `Organizational Unit Name (eg, section) []:Information Technology`\r\n    `!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!`\r\n    `!!!!!Common Name (eg, your name or your server's hostname) []:iot4pi.com !!!!!!!!`\r\n    `!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!`\r\n    `Email Address []:office@iot4pi`\r\n    `Please enter the following 'extra' attributes`\r\n    `to be sent with your certificate request`\r\n    `A challenge password []:`\r\n    `An optional company name []:`\r\n\r\nIf you have everything provided, the the script will finish successfully.\r\nThe server will now start automatically at the reboot of the Raspberry pi. \r\nPer default the server will listen at port 10023.\r\n\r\nYou can now proof that everything is running OK by:\r\n    \r\n    Testing if it starts at Boot with command \r\n            `$sudo crontab -l`\r\n            `it should present a line like:`\r\n            `@reboot sudo /home/pi/SSLPi/startSSLPi.sh >> /home/pi/SSLPi/log 2>&1`\r\n\r\n\r\n    after reboot you can test if the server is running with\r\n            `$ ps aux | grep SSLserverPi`\r\n            `this should bring something like`\r\n \r\n            `root 2133 0.0  0.5  4592 2640 ?  S  08:49 0:00 sudo python /home/pi/SSLPi/SSLserverPi_VX.py`\r\n\r\nYou will find the Server application in the specified installation directory. In this directory there\r\nwill be the app directory with the sample scripts. \r\nThe Certificates will be stored in the specified certification directory. There you will find\r\n\r\n    `-rw-r--r-- 1 root root 1147 Jan 27 15:31 server.cer`\r\n    `-rw-r--r-- 1 root root 1679 Jan 27 15:30 server.key`\r\n    `-rw-r--r-- 1 root root 1751 Jan 27 15:30 server.orig.key`\r\n    `-rw-r--r-- 1 root root 1338 Jan 27 15:31 server.pem`\r\n\r\nThe file server.pem is the important file you will need for the clients. This file you have to copy and\r\nprovide your clients with it. This one is the key to establish a communication withe the server. \r\nWithout it, the server would reject any communication attempt.  \r\n\r\n###After you have successfully installed the software you can configure the SSLserverPi \r\nto your own needs. This has to be done with the File SSLPi.cfg. \r\nThe configuration file SSLPi.cfg has to be stored in the same directory as the SSLserverPi_VersX.py.\r\n\r\nThe Configuration is separated in two sections. \r\nThe section **[SETUP]** takes care of the global behavior of the server.\r\nThe section **[APP_CALLS]** is the part where you call your own applications on the \r\nRaspberry pi. To give you an idea how it is done, we provide you with a few APP Call's \r\nand the referring applications/scripts which are stored in the directory app. \r\n\r\nPer default the server will listen at port 10023.\r\nIf you want to change the Port, go to the section [SETUP] \r\nand change the line \r\n    iPort:10023\r\nEverything else can be left unchanged in section [SETUP], \r\nif you have installed the server with the Install.sh.\r\n\r\nThe section [APP_CALLS] takes care of the Configuration of the applications which\r\nhave to be proceeded by the Server. \r\nA call is initiated by a Command which is sent from the Client to the Server.\r\nAn App Call can consist of one or more commands of the the server. Therefore an APP_CAll has a special format.\r\n\r\nThe format of APP_CALLS configuration Line is specified like this:\r\n\r\n`No.     : Command_In ; Sequence # ; OS Command ; App+Path ; Type ; Success Return ; Arg 1 ; ..; Arg n `\r\n\r\n\r\nAll entry have running Number and a Name called Command_In.\r\nThe Command_In is the command which could be called by a Client.\r\nThe Command_In is the name of the APP_CALL. \r\nAn APP_CALL will sent by the Client to the Server by the Command_In String.\r\nA Command_In/APP_CALL can have non or one Parameter !\r\n\r\nDue to the fact that an APP_CALL can consist of more then on command, we have to specify in which order the commands have \r\nto be proceeded by the the server. This order is specified by the sequence number Sequence Number.\r\n\r\nThe Value of OS Command can only be True or False. In case of an OS Command the App+Path needs only the command.\r\nThe operating systems takes care of the rest.\r\n\r\nThe App+Path should be the full Path and Name of the Command, except a OS Command is used. \r\n_Test_ is a special command, it is an internal command which will send a Test Message back to the Client. You also have to take\r\n care in the Type column using the _Test_ command.\r\n\r\nThe Type is needed by the Server, because depending on the Command Type it has to be handled different. \r\nFollowing Types are defined:\r\n\r\n    `Test Command (sends back Test message)\t\t    -- Value 0`\r\n    `Change Dir \t\t\t                            -- Value 1`\r\n    `(with defined directory in Argument section)`\r\n    `Command without a return (like rm ) \t\t    -- Value 2`\r\n    `Command with return (like ls or pwd)\t\t    -- Value 3`\r\n    `Command  handles the parameters, with return\t    -- Value 4`\r\n    `Command  handles the parameters, without return         -- Value 5`\r\n    `Command  handles the parameters,for Change Dir\t    -- Value 6  `\r\n\r\nAs you see there are already 7 types defined.\r\nThere are three groups. \r\n\r\n    `1) Value 0: the Test command which is an internal Test Function`\r\n    `2) Value 1 to 3: are Commands which will be proceeded by the Server without a Parameter`\r\n    `3) Value 4 to 6: the command which has to handle the parameter which is sent by the Client  `\r\n\r\nSo, as already mentioned one APP_CALL (Command_In) can consist of more then one \r\ncommands. If the APP_CALL (Command_In) is sent with one Parameter you have to \r\ndefine which command in the sequence will take care of this parameter.\r\nSee the configured examples in the SSLPi.cfg. \r\n\r\n**Info: **\r\n    All commands of one APP_CALL of a Client are proceeded in one run. \r\n    The server won't  interrupt to handle an other Client in-between.\r\n    Therefore it is guaranteed that you can edit files, change directories \r\n    and set IO's in one APP_CALL.   \r\n\r\nSuccess Return: specifies which values the the sever gets, if the launched command was successfully  processed.\r\nNormally you will 0 or 1 but sometimes you can not predict what you  will get but you can define what you do not want to get. \r\n    `In this case use the Reply string {!} (= must NOT be) with return Value (for instance {!}ERROR).`\r\n\r\nThe last column is for arguments. If a command should have an additional parameter, it is defined in the argument. \r\n    `For instance \"ls -l\" would be separated this way : \"ls\" into the App+Path column and \"-l\" as an argument.`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}